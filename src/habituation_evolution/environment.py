"""Environment generation for the habituation/sensitization simulation.

This module handles:
- Generating clumpy food/poison sequences
- Applying sensory noise (discrete or continuous modes)
- Batch environment generation for population evaluation
"""

from functools import partial
from typing import NamedTuple

import jax
import jax.numpy as jnp
from jax import Array
from jax.random import PRNGKey

from .config import EnvironmentConfig, NetworkConfig, NoiseMode


class Environment(NamedTuple):
    """Environment data for a single creature's lifespan.

    Attributes:
        true_sequence: Ground truth food (1) / poison (0) sequence. Shape: (lifespan,)
        perceived_sequence: What the creature perceives after noise. Shape: (lifespan,)
            - In discrete mode: 1 (food) or 0 (poison)
            - In continuous mode: continuous value (positive = food-like, negative = poison-like)
    """

    true_sequence: Array
    perceived_sequence: Array


def generate_base_sequence(key: PRNGKey, length: int) -> Array:
    """Generate random food(1)/poison(0) base sequence.

    Each element has 50% probability of being food or poison.

    Args:
        key: JAX random key
        length: Length of sequence to generate

    Returns:
        Binary array of shape (length,) with 1=food, 0=poison
    """
    return jax.random.bernoulli(key, p=0.5, shape=(length,)).astype(jnp.int32)


def expand_to_clumps(base_sequence: Array, clump_scale: int) -> Array:
    """Expand each element to clump_scale consecutive copies.

    For example, if base_sequence is [1, 0, 1] and clump_scale is 3,
    the result is [1, 1, 1, 0, 0, 0, 1, 1, 1].

    Args:
        base_sequence: Binary sequence of food/poison
        clump_scale: Number of times to repeat each element

    Returns:
        Expanded sequence of shape (len(base_sequence) * clump_scale,)
    """
    # Repeat each element clump_scale times
    return jnp.repeat(base_sequence, clump_scale)


def generate_clumpy_sequence(key: PRNGKey, lifespan: int, clump_scale: int) -> Array:
    """Generate a clumpy food/poison sequence for a creature's lifespan.

    The sequence is generated by:
    1. Creating a base random sequence of length ceil(lifespan / clump_scale)
    2. Expanding each element to clump_scale consecutive copies
    3. Truncating to exactly lifespan length

    This ensures:
    - Minimum clump length = clump_scale
    - Mean clump length = 2 * clump_scale
    - Maximum clump length can be up to lifespan (rare)

    Args:
        key: JAX random key
        lifespan: Target sequence length
        clump_scale: Scale of clumpiness

    Returns:
        Binary array of shape (lifespan,) with 1=food, 0=poison
    """
    # Calculate base sequence length needed
    # We need enough to cover lifespan after expansion
    base_length = (lifespan + clump_scale - 1) // clump_scale

    # Generate base sequence
    base_seq = generate_base_sequence(key, base_length)

    # Expand to clumps
    expanded = expand_to_clumps(base_seq, clump_scale)

    # Truncate to exact lifespan
    return expanded[:lifespan]


def apply_discrete_noise(
    key: PRNGKey, true_sequence: Array, accuracy: float
) -> Array:
    """Apply discrete (binary flip) sensory noise.

    With probability (1 - accuracy), the perception is flipped:
    food appears as poison, or poison appears as food.

    Args:
        key: JAX random key
        true_sequence: Ground truth food/poison sequence (binary)
        accuracy: Probability of correct perception [0.5, 1.0]

    Returns:
        Perceived sequence (binary) with noise applied
    """
    # Generate flip mask: True where perception should be flipped
    flip_mask = jax.random.bernoulli(key, p=(1.0 - accuracy), shape=true_sequence.shape)

    # XOR with flip mask to flip selected elements
    # true_sequence is 0 or 1, flip_mask is True/False
    # XOR: same = 0, different = 1
    perceived = jnp.where(flip_mask, 1 - true_sequence, true_sequence)

    return perceived


def apply_continuous_noise(
    key: PRNGKey,
    true_sequence: Array,
    accuracy: float,
    noise_std: float,
    sweet_input: float,
    sour_input: float,
) -> Array:
    """Apply continuous (Gaussian) sensory noise.

    The true sequence is converted to continuous values (sweet/sour),
    then Gaussian noise is added. The noise_std is scaled based on
    the accuracy parameter.

    Args:
        key: JAX random key
        true_sequence: Ground truth food/poison sequence (binary)
        accuracy: Target accuracy level [0.5, 1.0] - used to scale noise
        noise_std: Base standard deviation of Gaussian noise
        sweet_input: Continuous value for food perception
        sour_input: Continuous value for poison perception

    Returns:
        Continuous perceived values with noise applied
    """
    # Convert binary to continuous: food -> sweet_input, poison -> sour_input
    continuous_signal = jnp.where(
        true_sequence == 1, sweet_input, sour_input
    )

    # Scale noise based on accuracy
    # At accuracy=1.0, noise should be 0
    # At accuracy=0.5, noise should be maximal
    # We scale so that the probability of correct sign matches accuracy approximately
    noise_scale = noise_std * (2.0 * (1.0 - accuracy))

    # Add Gaussian noise
    noise = jax.random.normal(key, shape=continuous_signal.shape) * noise_scale
    perceived = continuous_signal + noise

    return perceived


def generate_environment(
    key: PRNGKey,
    env_config: EnvironmentConfig,
    net_config: NetworkConfig,
) -> Environment:
    """Generate complete environment for one creature's lifespan.

    Args:
        key: JAX random key
        env_config: Environment configuration
        net_config: Network configuration (for input encoding values)

    Returns:
        Environment with true and perceived sequences
    """
    key_seq, key_noise = jax.random.split(key)

    # Generate true clumpy sequence
    true_sequence = generate_clumpy_sequence(
        key_seq, env_config.lifespan, env_config.clump_scale
    )

    # Apply appropriate noise model
    if env_config.noise_mode == NoiseMode.DISCRETE:
        perceived_sequence = apply_discrete_noise(
            key_noise, true_sequence, env_config.sensory_accuracy
        )
        # Convert to input values for discrete mode
        perceived_sequence = jnp.where(
            perceived_sequence == 1, net_config.sweet_input, net_config.sour_input
        )
    else:  # CONTINUOUS
        perceived_sequence = apply_continuous_noise(
            key_noise,
            true_sequence,
            env_config.sensory_accuracy,
            env_config.noise_std,
            net_config.sweet_input,
            net_config.sour_input,
        )

    return Environment(true_sequence=true_sequence, perceived_sequence=perceived_sequence)


def generate_environments_batch(
    key: PRNGKey,
    env_config: EnvironmentConfig,
    net_config: NetworkConfig,
    batch_size: int,
) -> Environment:
    """Generate environments for an entire population.

    Args:
        key: JAX random key
        env_config: Environment configuration
        net_config: Network configuration
        batch_size: Number of environments to generate (typically population size)

    Returns:
        Environment with batched sequences of shape (batch_size, lifespan)
    """
    keys = jax.random.split(key, batch_size)

    # Vectorize environment generation over batch
    batch_generate = jax.vmap(
        lambda k: generate_environment(k, env_config, net_config)
    )

    return batch_generate(keys)


def generate_shared_environment(
    key: PRNGKey,
    env_config: EnvironmentConfig,
    net_config: NetworkConfig,
    batch_size: int,
) -> Environment:
    """Generate a single environment shared by all creatures in population.

    All creatures experience the same true sequence but may have different
    noise realizations.

    Args:
        key: JAX random key
        env_config: Environment configuration
        net_config: Network configuration
        batch_size: Number of noise realizations to generate

    Returns:
        Environment with:
        - true_sequence: shape (lifespan,) - shared
        - perceived_sequence: shape (batch_size, lifespan) - individual noise
    """
    key_seq, key_noise = jax.random.split(key)

    # Generate single true sequence
    true_sequence = generate_clumpy_sequence(
        key_seq, env_config.lifespan, env_config.clump_scale
    )

    # Generate individual noise for each creature
    noise_keys = jax.random.split(key_noise, batch_size)

    if env_config.noise_mode == NoiseMode.DISCRETE:
        # Vectorize discrete noise application
        apply_noise_batch = jax.vmap(
            lambda k: apply_discrete_noise(k, true_sequence, env_config.sensory_accuracy)
        )
        perceived_batch = apply_noise_batch(noise_keys)
        # Convert to input values
        perceived_batch = jnp.where(
            perceived_batch == 1, net_config.sweet_input, net_config.sour_input
        )
    else:  # CONTINUOUS
        apply_noise_batch = jax.vmap(
            lambda k: apply_continuous_noise(
                k,
                true_sequence,
                env_config.sensory_accuracy,
                env_config.noise_std,
                net_config.sweet_input,
                net_config.sour_input,
            )
        )
        perceived_batch = apply_noise_batch(noise_keys)

    # Broadcast true_sequence to batch shape for consistency
    true_sequence_batch = jnp.broadcast_to(
        true_sequence[None, :], (batch_size, env_config.lifespan)
    )

    return Environment(true_sequence=true_sequence_batch, perceived_sequence=perceived_batch)


# ============================================================================
# Utility functions for analysis
# ============================================================================


def compute_clump_statistics(sequence: Array) -> dict:
    """Compute statistics about clump lengths in a sequence.

    Args:
        sequence: Binary food/poison sequence

    Returns:
        Dictionary with min, max, mean clump lengths
    """
    # Find where changes occur
    changes = jnp.diff(sequence) != 0
    change_indices = jnp.where(changes)[0] + 1

    # Compute clump lengths
    all_indices = jnp.concatenate([
        jnp.array([0]),
        change_indices,
        jnp.array([len(sequence)])
    ])
    clump_lengths = jnp.diff(all_indices)

    return {
        "min": int(jnp.min(clump_lengths)),
        "max": int(jnp.max(clump_lengths)),
        "mean": float(jnp.mean(clump_lengths)),
        "num_clumps": len(clump_lengths),
    }


def compute_accuracy_empirical(true_sequence: Array, perceived_sequence: Array) -> float:
    """Compute empirical accuracy from true and perceived sequences.

    For discrete mode, this is the fraction of correct perceptions.
    For continuous mode, this is the fraction where sign matches.

    Args:
        true_sequence: Ground truth sequence (binary)
        perceived_sequence: Perceived sequence (binary or continuous)

    Returns:
        Empirical accuracy as float
    """
    # Convert perceived to binary based on sign (for continuous mode)
    # Assumes sweet > 0 and sour < 0
    perceived_binary = (perceived_sequence > 0).astype(jnp.int32)

    # Compare with true sequence
    matches = true_sequence == perceived_binary

    return float(jnp.mean(matches))
